My Solutions for "Ninety-Nine Haskell Problems"
===============================================

The problems are listed [here](http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems).

Problem 1
---------

### Description

Find the last element of a list.

Example in Haskell:

    Prelude> myLast [1,2,3,4]
    4
    Prelude> myLast ['x','y','z']
    'z'

### Solutions

```haskell
myLast :: [a] -> a
myLast [x] = x
myLast (_:xs) = myLast xs
    
myLast' :: [a] -> a
myLast' = head . reverse
    
myLast'' :: [a] -> a
myLast'' = foldl1 (flip const)    
    
myLast''' :: [a] -> a
myLast''' = foldr1 (flip const)
    
-- The following are confusing and amazing. 
    
myLast'''' :: [a] -> a
myLast'''' = foldr1 (const id)
    
myLast''''' :: [a] -> a
myLast''''' = foldl1 (const id)
```
Problem 2
---------

### Description

Find the last but one element of a list.

Example in Haskell:

    Prelude> myButLast [1,2,3,4]
    3
    Prelude> myButLast ['a'..'z']
    'y'
    
### Solutions

```haskell
myButLast :: [a] -> a
myButLast x = reverse x !! 1
    
myButLast' :: [a] -> a
myButLast' [x, _] = x
myButLast' (x : xs) = myButLast' xs
    
myButLast'' :: [a] -> a
myButLast'' = last . init
    
myButLast''' :: [a] -> a
myButLast''' = head . tail . reverse
```

Problem 3
---------

### Description

Find the K'th element of a list. The first element in the list is number 1.

Example in Haskell

    Prelude> elementAt [1,2,3] 2
    2
    Prelude> elementAt "haskell" 5
    'e'

### Solutions

```haskell
elementAt :: [a] -> Int -> a
elementAt xs i = xs !! (i - 1)
    
elementAt' :: [a] -> Int -> a
elementAt' (x : _) 1 = x 
elementAt' (_ : xs) i 
  | i < 1 = error "Index out of bounds"
  | otherwise = elementAt' xs (i-1)
elementAt' [] _ = error "Index out of bounds"
    
elementAt'' :: [a] -> Int -> a
elementAt'' xs i = last . take i $ xs 
```
Problem 4
---------

### Description

Find the number of elements of a list.

Example in Haskell:

    Prelude> myLength [123, 456, 789]
    3
    Prelude> myLength "Hello, world!"
    13
    
### Solutions

```haskell
myLength :: [a] -> Int
myLength [] = 0 
myLength (_ : xs) = 1 + myLength xs
    
myLength' :: [a] -> Int
myLength' = sum . map (\x -> 1)
    
myLength'' :: [a] -> Int
myLength'' = foldl (\n _ -> n+1) 0
    
myLength''' :: [a] -> Int
myLength''' = foldr (\_ n -> n+1) 0
    
myLength'''' :: [a] -> Int
myLength'''' = foldr (const (+1)) 0
```

Problem 5
---------

### Description

Reverse a list.

Example in Haskell:

    Prelude> reverse "A man, a plan, a canal, panama!"
    "!amanap ,lanac a ,nalp a ,nam A"
    Prelude> reverse [1,2,3,4]
    [4,3,2,1]

### Solutions

```haskell
reverse' :: [a] -> [a]
reverse' [] = []
reverse' (x:xs) = reverse' xs ++ [x]
    
reverse'' :: [a] -> [a]
reverse'' = foldl (flip (:)) []
    
reverse''' :: [a] -> [a]
reverse''' list = reverse'''' list []
  where reverse'''' [] reversed = reversed
        reverse'''' (x:xs) reversed = reverse'''' xs (x:reversed)
```

Problem 6
---------

### Description

Find out whether a list is a palindrome. A palindrome can be read forward or backward; e.g. (x a m a x).

Example in Haskell:

    Prelude> isPalindrome [1,2,3]
    False
    Prelude> isPalindrome "madamimadam"
    True
    Prelude> isPalindrome [1,2,4,8,16,8,4,2,1]
    True

### Solutions

```haskell
isPalindrome :: (Eq a) => [a] -> Bool
isPalindrome list = list == reverse list
    
isPalindrome' :: (Eq a) => [a] -> Bool
isPalindrome' [] = True
isPalindrome' [_] = True
isPalindrome' list = (head list) == (last list) && (isPalindrome' $ init $ tail list)
```
