My Solutions for "Ninety-Nine Haskell Problems"
===============================================

The problems are listed [here](http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems).

Problem 1
---------

### Description

Find the last element of a list.

Example in Haskell:

    Prelude> myLast [1,2,3,4]
    4
    Prelude> myLast ['x','y','z']
    'z'

### Solutions

```haskell
myLast :: [a] -> a
myLast [x] = x
myLast (_:xs) = myLast xs
    
myLast' :: [a] -> a
myLast' = head . reverse
    
myLast'' :: [a] -> a
myLast'' = foldl1 (flip const)    
    
myLast''' :: [a] -> a
myLast''' = foldr1 (flip const)
    
-- The following are confusing and amazing. 
    
myLast'''' :: [a] -> a
myLast'''' = foldr1 (const id)
    
myLast''''' :: [a] -> a
myLast''''' = foldl1 (const id)
```
Problem 2
---------

### Description

Find the last but one element of a list.

Example in Haskell:

    Prelude> myButLast [1,2,3,4]
    3
    Prelude> myButLast ['a'..'z']
    'y'
    
### Solutions

```haskell
myButLast :: [a] -> a
myButLast x = reverse x !! 1
    
myButLast' :: [a] -> a
myButLast' [x, _] = x
myButLast' (x : xs) = myButLast' xs
    
myButLast'' :: [a] -> a
myButLast'' = last . init
    
myButLast''' :: [a] -> a
myButLast''' = head . tail . reverse
```

Problem 3
---------

### Description

Find the K'th element of a list. The first element in the list is number 1.

Example in Haskell

    Prelude> elementAt [1,2,3] 2
    2
    Prelude> elementAt "haskell" 5
    'e'

### Solutions

```haskell
elementAt :: [a] -> Int -> a
elementAt xs i = xs !! (i - 1)
    
elementAt' :: [a] -> Int -> a
elementAt' (x : _) 1 = x 
elementAt' (_ : xs) i 
  | i < 1 = error "Index out of bounds"
  | otherwise = elementAt' xs (i-1)
elementAt' [] _ = error "Index out of bounds"
    
elementAt'' :: [a] -> Int -> a
elementAt'' xs i = last . take i $ xs 
```
Problem 4
---------

### Description

Find the number of elements of a list.

Example in Haskell:

    Prelude> myLength [123, 456, 789]
    3
    Prelude> myLength "Hello, world!"
    13
    
### Solutions

```haskell
myLength :: [a] -> Int
myLength [] = 0 
myLength (_ : xs) = 1 + myLength xs
    
myLength' :: [a] -> Int
myLength' = sum . map (\x -> 1)
    
myLength'' :: [a] -> Int
myLength'' = foldl (\n _ -> n+1) 0
    
myLength''' :: [a] -> Int
myLength''' = foldr (\_ n -> n+1) 0
    
myLength'''' :: [a] -> Int
myLength'''' = foldr (const (+1)) 0
```

Problem 5
---------

### Description

Reverse a list.

Example in Haskell:

    Prelude> reverse "A man, a plan, a canal, panama!"
    "!amanap ,lanac a ,nalp a ,nam A"
    Prelude> reverse [1,2,3,4]
    [4,3,2,1]

### Solutions

```haskell
reverse' :: [a] -> [a]
reverse' [] = []
reverse' (x:xs) = reverse' xs ++ [x]
    
reverse'' :: [a] -> [a]
reverse'' = foldl (flip (:)) []
    
reverse''' :: [a] -> [a]
reverse''' list = reverse'''' list []
  where reverse'''' [] reversed = reversed
        reverse'''' (x:xs) reversed = reverse'''' xs (x:reversed)
```

Problem 6
---------

### Description

Find out whether a list is a palindrome. A palindrome can be read forward or backward; e.g. (x a m a x).

Example in Haskell:

    Prelude> isPalindrome [1,2,3]
    False
    Prelude> isPalindrome "madamimadam"
    True
    Prelude> isPalindrome [1,2,4,8,16,8,4,2,1]
    True

### Solutions

```haskell
isPalindrome :: Eq a => [a] -> Bool
isPalindrome list = list == reverse list
    
isPalindrome' :: Eq a => [a] -> Bool
isPalindrome' [] = True
isPalindrome' [_] = True
isPalindrome' list = (head list) == (last list) && (isPalindrome' $ init $ tail list)
```

Problem 7
---------

### Description

Flatten a nested list structure.

Transform a list, possibly holding lists as elements into a "flat" list by replacing each list with its elements (recursively).

Example in Haskell:

    Prelude> flatten (Elem 5)
    [5]
    Prelude> flatten (List [Elem 1, List [Elem 2, List [Elem 3, Elem 4], Elem 5]])
    [1,2,3,4,5]
    Prelude> flatten (List [])
    []

### Solutions

We should define a data structure like this:
```haskell
data NestedList a = Elem a | List [NestedList a]
```
The following are the solutions:
```haskell
flatten :: NestedList a -> [a]
flatten (Elem x) = [x]
flatten (List x) = concatMap flatten x
    
flatten' :: NestedList a -> [a]
flatten' (Elem x) = [x]
flatten' (List []) = []
flatten' (List (x:xs)) = flatten' x ++ flatten' (List xs)
    
flatten'' :: NestedList a -> [a]
flatten'' (Elem x) = [x]
flatten'' (List x) = foldr (++) [] $ map flatten'' x
```

Problem 8
---------

### Description

Eliminate consecutive duplicates of list elements.

If a list contains repeated elements they should be replaced with a single copy of the element. The order of the elements should not be changed.

Example in Haskell:

    Prelude> compress ["a","a","a","a","b","c","c","a","a","d","e","e","e","e"]
    ["a","b","c","a","d","e"]
    
### Solutions

```haskell
compress :: Eq a => [a] -> [a]
compress = foldr compHelp []
  where compHelp x [] = [x]
        compHelp x (y:ys) 
          | x == y = y:ys
          | otherwise = x:y:ys
      
compress' :: Eq a => [a] -> [a]
compress' [] = []
compress' (x:xs) = x : (compress $ dropWhile (== x) xs)
    
compress'' :: Eq a => [a] -> [a]
compress'' x = foldr (\a b -> if a == (head b) then b else a:b) [last x] x
```

If we import functions in Data.List, then we could have an easier version:

```haskell
compress''' :: Eq a => [a] -> [a]
compress''' = map head . group
```

Problem 9
---------

### Description

Pack consecutive duplicates of list elements into sublists. If a list contains repeated elements they should be placed in separate sublists.

Example in Haskell:
    
    Prelude> pack ['a', 'a', 'a', 'a', 'b', 'c', 'c', 'a', 'a', 'd', 'e', 'e', 'e', 'e']
    ["aaaa","b","cc","aa","d","eeee"]
    
### Solutions

There is a most trivial version:

```haskell
pack :: Eq a => [a] -> [[a]]
pack [] = []
pack (x:xs) = packHelper [] [] (x:xs)
  where packHelper result [] [] = result
        packHelper result current [] = result ++ [current]
        packHelper result [] (x:xs) = packHelper result [x] xs
        packHelper result current@(y:_) (x:xs) 
          | y == x = packHelper result (x:current) xs
          | otherwise = packHelper (result ++ [current]) [x] xs
```

The structure of packHelper implies me to use foldr:

```haskell
pack' :: Eq a => [a] -> [[a]]
pack' = foldr packHelper []
  where packHelper item [] = [[item]]
        packHelper item result@(x:xs)
          | item == head x = (item:x) : xs
          | otherwise = [item] : result
```

It's actually the function Data.List.group. The implementation is:

```haskell
pack'' :: Eq a => [a] -> [[a]]
pack'' [] = []
pack'' (x:xs) = let (first, rest) = span (==x) xs
                in (x:first) : pack'' rest
```

Problem 10
----------

### Description

Run-length encoding of a list. Use the result of problem P09 to implement the so-called run-length encoding data compression method. Consecutive duplicates of elements are encoded as lists (N E) where N is the number of duplicates of the element E.

Example in Haskell:
    
    Prelude> encode "aaaabccaadeeee"
    [(4,'a'),(1,'b'),(2,'c'),(2,'a'),(1,'d'),(4,'e')]
    
### Solutions

If we use Data.List.group, the solution is obvious:

```haskell
encode :: Eq a => [a] -> [(Int, a)]
encode list = let grouped = group list
              in zip (map length grouped) (map head grouped)
          
encode' :: Eq a => [a] -> [(Int, a)]
encode' = map (\x -> (length x, head x)) . group
```
Also we could have a version which uses foldr:

```haskell
encode'' :: Eq a => [a] -> [(Int, a)]
encode'' = foldr encodeHelper []
  where encodeHelper item [] = [(1, item)]
        encodeHelper item result@((count, x):xs)
          | item == x = (count + 1, x):xs
          | otherwise = (1, item) : result
```

Problem 11
----------

### Description

Modified run-length encoding.

Modify the result of problem 10 in such a way that if an element has no duplicates it is simply copied into the result list. Only elements with duplicates are transferred as (N E) lists.

Example in Haskell:

    Prelude> encodeModified "aaaabccaadeeee"
    [Multiple 4 'a',Single 'b',Multiple 2 'c',Multiple 2 'a',Single 'd',Multiple 4 'e']

### Solutions

```haskell
data Problem11 a = Single a | Multiple Int a deriving (Show)
encodeModified :: Eq a => [a] -> [Problem11 a]
encodeModified = map transformHelper . encode
  where transformHelper (1, x) = Single x
        transformHelper (n, x) = Multiple n x
```

Problem 12
----------

### Description

Decode a run-length encoded list.

Given a run-length code list generated as specified in problem 11. Construct its uncompressed version.

Example in Haskell:

    Prelude>> decodeModified [Multiple 4 'a',Single 'b',Multiple 2 'c',Multiple 2 'a',Single 'd',Multiple 4 'e']
    "aaaabccaadeeee"
    
### Solutions

```haskell
decodeModified :: [Problem11 a] -> [a]
decodeModified = concatMap decodeHelper
  where decodeHelper (Single x) = [x]
        decodeHelper (Multiple n x) = replicate n x
```

Problem 13
----------

### Description

Run-length encoding of a list (direct solution).

Implement the so-called run-length encoding data compression method directly. I.e. don't explicitly create the sublists containing the duplicates, as in problem 9, but only count them. As in problem P11, simplify the result list by replacing the singleton lists (1 X) by X.

Example in Haskell:

    Prelude> encodeDirect "aaaabccaadeeee"
    [Multiple 4 'a',Single 'b',Multiple 2 'c',Multiple 2 'a',Single 'd',Multiple 4 'e']
    
### Solutions

```haskell
encodeDirect :: Eq a => [a] -> [Problem11 a]
encodeDirect = foldr encodeHelper []
  where encodeHelper x result@(h:rest) 
          | (getContent h) == x = (Multiple (1 + getCount h) x) : rest
          | otherwise = (Single x) : result
        encodeHelper x [] = [(Single x)]
        getContent (Single x) = x
        getContent (Multiple _ x) = x
        getCount (Single _) = 1
        getCount (Multiple n _) = n
```

Problem 14
----------

### Description

Duplicate the elements of a list.

Example in Haskell:

    Prelude> dupli [1, 2, 3]
    [1,1,2,2,3,3]
    
### Solutions
    
```haskell
dupli :: [a] -> [a]
dupli = concatMap (\x->[x,x])
    
dupli' :: [a] -> [a]
dupli' = foldr (\x xs -> x:x:xs) []
```

Problem 15
----------

### Description

Replicate the elements of a list a given number of times.

Example in Haskell:

    Prelude> repli "abc" 3
    "aaabbbccc"
    
### Solutions
```haskell
repli :: [a] -> Int -> [a]
repli xs n = concatMap (replicate n) xs
    
repli' :: [a] -> Int -> [a]
repli' = flip $ concatMap . replicate
```
